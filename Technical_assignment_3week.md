Авторизация и аутентификация. Написание сервисов.

- Настроить аутентификацию и авторизацию пользователя в БД:
- Заменить InMemoryUserDetailsManager на JdbcUserDetailsManager.
- Настроить SecurityFilterChain таким образом, чтобы выполнялись требования к модели безопасности.
- Добавить дополнительные проверки ролей в тех методах, где невозможно проверить авторизацию с помощью SecurityFilterChain, — например, редактирование чужого комментария или объявления.
- Связать данные, которые приходят в контроллеры в виде DTO, с БД. Другими словами, вам нужно написать сервисы, которые будут работать с БД при помощи репозиториев, а также использовать мапперы для преобразования объектов из DTO в сущности и обратно.

Рекомендации по аутентификации и авторизации:
Фронтенд-часть использует Basic-аутентификацию, поэтому на стороне сервера она уже включена (в WebSecurityConfig).
За настройку Spring Security отвечают класс WebSecurityConfig и зависимость spring-boot-starter-security в POM-файле.
Для того чтобы делать запросы с Basic-аутентификацией в ваше приложение, в запрос нужно добавить хедер Authorization: Authorization: Basic base64Encode(user:password)
где:
user — это имя пользователя,
password — это пароль пользователя,
base64Encode — функция кодирования в формат Base64.
То есть в хедере Authorization после Basic идут закодированные при помощи Base64 логин и пароль.

За настройку Security-контекста отвечает:

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
http.csrf()
.disable()
.authorizeHttpRequests(
authorization ->
authorization
.mvcMatchers(AUTH_WHITELIST)
.permitAll()
.mvcMatchers("/ads/**", "/users/**")
.authenticated())
.cors()
.and()
.httpBasic(withDefaults());
return http.build();
}

За хранение пользователей, которые будут использоваться при аутентификации, по умолчанию отвечает:

@Bean
public InMemoryUserDetailsManager userDetailsService(PasswordEncoder passwordEncoder) {
UserDetails user =
User.builder()
.username("user@gmail.com")
.password("password")
.passwordEncoder(passwordEncoder::encode)
.roles(Role.USER.name())
.build();
return new InMemoryUserDetailsManager(user);
}

Как видно, у пользователя есть имя (email/username), пароль и роль. Бин из кода выше хранит пользователей в памяти приложения. Вам нужно сделать так, чтобы пользователи хранились в БД и при аутентификации данные запрашивались из БД. Для этого вместо InMemoryUserDetailsManager надо использовать JdbcUserDetailsManager или UserDetailsService.
Теперь о том, как можно получить username пользователя из аутентификационных данных.
Самый простой способ — в метод контроллера передать Authentication authentication — у него уже есть метод getName, который выдает username пользователя.

Пример:
@PostMapping("/set_password")
public NewPassword setPassword(@RequestBody NewPassword newPassword, Authentication authentication) {
NewPassword resultPassword = new NewPassword();
authService.changePassword(
authentication.getName(),
newPassword.getCurrentPassword(),
newPassword.getNewPassword()
)
.ifPresent(resultPassword::setCurrentPassword);
return resultPassword;
}

На данном этапе работы над проектом нужно добавить ограничения на уровне бэкенд-части. Даже если на фронтенд-части проекта предусмотрена возможность для пользователей менять или удалять только свои объявления или комментарии, на стороне сервера всё равно нужно делать проверки, т. к. можно сформировать с использованием, например, Postman запрос на удаление/редактирование чужого объявления/комментария, и если на сервере не будет проверок, то возникнет, по сути, дыра в безопасности.
Для проверок возможности удалять/редактировать объявления/комментарии можно использовать аннотацию @PreAuthorize либо другую из статьи для описания внутри нее условия вызова метода (при помощи SpEL можно написать boolean-выражение, которое определит, можно ли вызывать метод конкретному пользователю или нет).

Рекомендации по сервисам
Вы можете обратить внимание на то, что в спецификации используется обозначение pk. В полях объектов pk означает primary key, или первичный ключ. Если обратиться к Spring Data, то над полем, которое является первичным ключом, ставится аннотация @Id .
Также в выданном API в некоторых запросах вы можете заметить, что не хватает данных на вход. Например, имени пользователя. В этом случае такие данные нужно брать из авторизации.



Работа будет оценена по следующим критериям:
- Приложение работает в соответствии с OpenAPI-спецификацией.
- Аутентификация и авторизация происходит на основе данных в БД.
- Неавторизованный пользователь может получать список объявлений.
- Авторизованный пользователь с ролью USER может получать список объявлений.
- Авторизованный пользователь с ролью USER может получать объявление по id.
- Авторизованный пользователь с ролью USER может создавать объявление.
- Авторизованный пользователь с ролью USER может редактировать и удалять свое объявление.
- Авторизованный пользователь с ролью USER может получать список комментариев.
- Авторизованный пользователь с ролью USER может создавать комментарии.
- Авторизованный пользователь с ролью USER может редактировать свои комментарии.
- Авторизованный пользователь с ролью USER может удалять свои комментарии.
- Авторизованный пользователь с ролью ADMIN может редактировать или удалять объявления и комментарии любых других пользователей.
- Реализован эндпойнт смены пароля пользователя.
- Эндпойнты с неправильным логином возвращают код 401.
- Эндпойнты с неправильным логином возвращают код 401.
- Эндпойнты с недопустимой ролью возвращают код 403.
- Код полностью покрыт тестами.
- К классам и методам контроллеров применены документирующие аннотации Swagger.
- К классам DTO применены документирующие аннотации Swagger.
- При выполнении цикла CRUD-операций (POST, GET, PUT, DELETE) не возвращается статус ответа 200.
- Соблюден паттерн MVC.
- Созданы пакеты model, serivce, controller.
- HTTP-методы используются по правилам построения REST-запросов.
- В контроллере есть только метод вызова сервиса и нет лишней логики.
- Коды HTTP-ответов соответствуют их семантике.
- Соблюдена инкапсуляция.
- Название метода начинается с глагола и описывает действия метода.
- Применяется принцип camelCase.
- Код комплируется, и каждое действие расположено на отдельной строке.
- Параметры для фильтрации переданы через @RequestParam.
- Использовано автоматическое форматирование кода.
- В репозитории нет лишних файлов.
- Переданная ссылка — это pull request.
- Отсутствуют лишние блоки и переменные.
- Имена классов начинаются с большой буквы.
- Нет двойной вложенности.
- Соблюдена конвенциональная структура класса: поля, конструкторы и методы.
- Полям присвоены имена, которые отражают их суть.
- Каждый класс находится в отдельном файле.
- Классы корректно распределены по пакетам.
- Отсутствуют лишние нефункциональные комментарии.
- Отсутствуют методы, оперирующие raw type.
- Повторяющийся хардкод вынесен в константы.
- Отсутствуют методы, чья логика может вернуть null.
- URL-маппинг прописан по правилам построения REST-запросов.
- Метод POST возвращает id созданной сущности.
- Метод DELETE возвращает void.
- Метод PUT возвращает обновленное состояние сущности.
- Эндпойнты семантически подходят к контроллерам, в которых они реализованы.
- Контроллеры реализованы без использования класса ResponseEntity (кроме выгрузки файлов).
