- Подключить БД PostgreSQL.
- Создать необходимые сущности: пользователь, объявление, комментарий.
- Решение о том, какие поля добавлять в эти сущности, надо принять на основе DTO, которые вы написали на предыдущем этапе.
- Написать репозитории для работы с созданными сущностями.
- Написать сервисы, которые маппят (устанавливают соответствие) из сущностей в DTO и обратно.


Советы:
Первое, с чего необходимо начать, — подключить базу данных к нашему проекту.
Далее нужно проанализировать данные, которыми обмениваются клиентская и серверная стороны, и на основе этого анализа составить модель данных — сущности и таблицы.
На данном этапе реализации проекта нужно добавить все DTO и Entity в проект.
DTO — это не то же самое, что сущности. Сущности (а по сути — таблицы БД) не должны содержать избыточных данных (колонок), также должны быть правильно расставлены связи между ними.
Далее необходимо написать мапперы для сущностей.
Маппинг — процесс сопоставления полей объекта одного класса с полями объекта другого класса. То есть это установление соотношения между моделями данных, которые находятся в разных источниках или системах. В нашем случае это процесс конвертации DTO-класса в Entity и обратно.
Код, который маппит, нужно написать самому.
Также на этом этапе должны быть созданы все необходимые репозитории для работы с сущностями.


Критерии оценки:
- Созданы сущности, отражающие функциональность приложения.
- Сущности содержат ограничения, согласующиеся со спецификацией OpenAPI.
- Сущности используют корректные типы данных, согласующиеся со спецификацией OpenAPI.
- Сущности содержат корректные связи, отсутствует избыточность данных.
- Для каждой сущности написан маппер, который трансформирует сущность в DTO.
- В pom.xml добавлен драйвер PostgreSQL.
- Создан класс-энтити «Пользователь», который соответствует всем требованиям сущности.
- Создан класс-энтити «Объявление», который соответствует всем требованиям сущности.
- Создан класс-энтити «Комментарий», который соответствует всем требованиям сущности.
- Создан репозиторий для энтити-класса «Пользователь».
- Создан репозиторий для энтити-класса «Объявление».
- Создан репозиторий для энтити-класса «Объявление».
- Реализованы мапперы из энтити в ДТО и обратно.
- Подключен liquibase и созданы скрипты, полностью описывающие схему данных.
- В проперти-файле указано spring.jpa.hibernate.ddl-auto=validate.
- Мапперы реализованы с помощью mapstruct.
- Запросы в спринговых репозиториях делаются с помощью именованных методов в репозиториях или с помощью @Query + JPQL.
- Установлена феч-стратегия FetchType.LAZY.
- Код полностью покрыт тестами.
- К классам и методам контроллеров применены документирующие аннотации Swagger.
- К классам DTO применены документирующие аннотации Swagger.
- При выполнении цикла CRUD-операций (POST, GET, PUT, DELETE) не возвращается статус ответа 200.
- Соблюден паттерн MVC.
- Созданы пакеты model, serivce, controller.
- HTTP-методы используются по правилам построения REST-запросов.
- В контроллере есть только метод вызова сервиса и нет лишней логики.
- Коды HTTP-ответов соответствуют их семантике.
- Соблюдена инкапсуляция.
- Название метода начинается с глагола и описывает действия метода.
- Применяется принцип camelCase.
- Код комплируется, и каждое действие расположено на отдельной строке.
- Параметры для фильтрации переданы через @RequestParam.
- Использовано автоматическое форматирование кода.
- В репозитории нет лишних файлов.
- Переданная ссылка — это pull request.
- Отсутствуют лишние блоки и переменные.
- Имена классов начинаются с большой буквы.
- Нет двойной вложенности.
- Соблюдена конвенциональная структура класса: поля, конструкторы и методы.
- Полям присвоены имена, которые отражают их суть.
- Каждый класс находится в отдельном файле.
- Классы корректно распределены по пакетам.
- Отсутствуют лишние нефункциональные комментарии.
- Отсутствуют методы, оперирующие raw type. 
- Повторяющийся хардкод вынесен в константы.
- Отсутствуют методы, чья логика может вернуть null.
- URL-маппинг прописан по правилам построения REST-запросов.
- Метод POST возвращает id созданной сущности.
- Метод DELETE возвращает void.
- Метод PUT возвращает обновленное состояние сущности.
- Эндпойнты семантически подходят к контроллерам, в которых они реализованы.
- Контроллеры реализованы без использования класса ResponseEntity (кроме выгрузки файлов).
